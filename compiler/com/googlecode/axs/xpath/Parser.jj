/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*//** * This is the parser for the subset of XPath which is allowed in {@literal @}XPath declarations. */options{  JDK_VERSION = "1.6";  STATIC = false;  UNICODE_INPUT = true;  FORCE_LA_CHECK = true;  CHOICE_AMBIGUITY_CHECK = 4;  OTHER_AMBIGUITY_CHECK = 4;                           }PARSER_BEGIN(Parser)package com.googlecode.axs.xpath;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/  public static void main(String args [])  {    System.out.println("Reading from standard input...");    System.out.print("Enter an expression like /root/node1//node3[@attr='foo'] : ");    Parser p = new Parser(System.in);    try    {      SimpleNode n = p.Start();      n.dump("");      System.out.println("Thank you.");    }    catch (Exception e)    {      System.out.println("Oops.");      System.out.println(e.getMessage());    }  }}PARSER_END(Parser)SKIP : /* tolerate errant whitespace */{  " "| "\t"| "\r"| "\n"}MORE : /* Comments */{  "(:" : IN_COMMENT}<IN_COMMENT>SPECIAL_TOKEN :{  < COMMENT : "*)" > : DEFAULT}<IN_COMMENT>MORE :{  < ~[] >}TOKEN : /* Literals */{  < INTEGER_LITERAL : ("-")? ([ "0"-"9" ])+ >| < DQUOT_LITERAL : "\"" ( (~["\\"]) | "\"\"" )* "\"" >| < SQUOT_LITERAL : "'" ( (~["'"]) | "''" )* "'" >}TOKEN : /* Operators */{  < EQ : "=" >| < NE : "!=" >| < LT : "<" >| < GT : ">" >| < LE : "<=" >| < GE : ">=" >}XPathNode Start() :{/*@bgen(jjtree) Start */
  XPathNode jjtn000 = new XPathNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Start */
  try {
/*@egen*/  Expression() ( "|" Expression() )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void Expression() :{/*@bgen(jjtree) Expression */
  XPathNode jjtn000 = new XPathNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Expression */
  try {
/*@egen*/  AbsolutePathExpression()| "//" RelativePathExpression()| RelativePathExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void AbsolutePathExpression() :{/*@bgen(jjtree) AbsolutePathExpression */
  XPathNode jjtn000 = new XPathNode(JJTABSOLUTEPATHEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) AbsolutePathExpression */
  try {
/*@egen*/  "/" RelativePathExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void RelativePathExpression()       :{}{  StepExpression() ( LOOKAHEAD(2) ChildExpression() | DecendentExpression() )*}void ChildExpression() :{/*@bgen(jjtree) ChildExpression */
  XPathNode jjtn000 = new XPathNode(JJTCHILDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) ChildExpression */
  try {
/*@egen*/  "/" StepExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void DecendentExpression() :{/*@bgen(jjtree) DecendentExpression */
  XPathNode jjtn000 = new XPathNode(JJTDECENDENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) DecendentExpression */
  try {
/*@egen*/  "//" StepExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void StepExpression()       :{}{  ForwardAxisStep() ( Predicate() )*}void ForwardAxisStep()       :{}{  Name()| Wildcard()}void Wildcard() :{/*@bgen(jjtree) Wildcard */
  XPathNode jjtn000 = new XPathNode(JJTWILDCARD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Wildcard */
  try {
/*@egen*/  "*"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void Predicate() :{/*@bgen(jjtree) Predicate */
  XPathNode jjtn000 = new XPathNode(JJTPREDICATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicate */
  try {
/*@egen*/  LOOKAHEAD(3)  "[" Integer() "]"| "[" OrExpression() "]"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void OrExpression()                   :{/*@bgen(jjtree) #OrExpression(> 1) */
  XPathNode jjtn000 = new XPathNode(JJTOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) #OrExpression(> 1) */
  try {
/*@egen*/  AndExpression() ( "or" AndExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/}void AndExpression()                    :{/*@bgen(jjtree) #AndExpression(> 1) */
  XPathNode jjtn000 = new XPathNode(JJTANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) #AndExpression(> 1) */
  try {
/*@egen*/  ComparisonExpression() ( "and" ComparisonExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/}void ComparisonExpression() :{/*@bgen(jjtree) ComparisonExpression */
  XPathNode jjtn000 = new XPathNode(JJTCOMPARISONEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) ComparisonExpression */
  try {
/*@egen*/  ValueExpression()  	( t = < EQ > | t = < NE > | t = < LT > | t = < GT > | t = < LE > | t = < GE > ) ValueExpression()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.jjtSetValue(t.image);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void ValueExpression()       :{}{  ( "(" OrExpression() ")" )  | Integer()  | String()  | AttributeExpression()  | FunctionExpression()}void Integer() :{/*@bgen(jjtree) Integer */
  XPathNode jjtn000 = new XPathNode(JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) Integer */
  try {
/*@egen*/  t = < INTEGER_LITERAL >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.jjtSetValue(t.image);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void String() :{/*@bgen(jjtree) String */
  XPathNode jjtn000 = new XPathNode(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) String */
  try {
/*@egen*/  t = < DQUOT_LITERAL >| t = < SQUOT_LITERAL >/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/ {  	jjtn000.jjtSetValue(t.image); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void AttributeExpression() :{/*@bgen(jjtree) AttributeExpression */
  XPathNode jjtn000 = new XPathNode(JJTATTRIBUTEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) AttributeExpression */
  try {
/*@egen*/  Name()| "@" Name()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void FunctionExpression() :{/*@bgen(jjtree) FunctionExpression */
  XPathNode jjtn000 = new XPathNode(JJTFUNCTIONEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) FunctionExpression */
  try {
/*@egen*/  t = "position" "(" ")"| t = "captureattrs" "(" ")"| t = "not" "(" OrExpression() ")"/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/{  jjtn000.jjtSetValue(t.image);}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}
void Name() :{/*@bgen(jjtree) Name */
  XPathNode jjtn000 = new XPathNode(JJTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) Name */
  try {
/*@egen*/  t = < NAME >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.jjtSetValue(t.image);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/* Names have the lowest priority when tokenizing */TOKEN : /* Names, taken from http://www.w3.org/TR/REC-xml/#NT-Name */{  < NAME : <NAME_START_CHAR> ( <NAME_CHAR> )* >| < #NAME_START_CHAR :		":"	| ["A"-"Z"]	| "_"	| ["a"-"z"]	| ["\u00c0"-"\u00d6"]	| ["\u00d8"-"\u00f6"]	| ["\u00f8"-"\u02ff"]	| ["\u0370"-"\u037d"]	| ["\u037f"-"\u1fff"]	| ["\u200c"-"\u200d"]	| ["\u2070"-"\u218f"]	| ["\u2c00"-"\u2fef"]	| ["\u3001"-"\ud7ff"]	| ["\uf900"-"\ufdcf"]	| ["\ufdf0"-"\ufffd"]//	| ["\u10000"-"\uefffF"] // FIXME: can I express this in Java?  >| <  #NAME_CHAR : 		<NAME_START_CHAR>	| "-"	| "."	| ["0"-"9"]	| "\u00b7"	| ["\u0300"-"\u036f"]	| ["\u203f"-"\u2040"]  >}