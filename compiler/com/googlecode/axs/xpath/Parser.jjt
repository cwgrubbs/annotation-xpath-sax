/** * This is the parser for the subset of XPath which is allowed in {@literal @}XPath declarations. */options{  JDK_VERSION = "1.6";  STATIC = false;  UNICODE_INPUT = true;  FORCE_LA_CHECK = true;  CHOICE_AMBIGUITY_CHECK = 4;  OTHER_AMBIGUITY_CHECK = 4;  MULTI = true;  NODE_PREFIX = "";  VISITOR = true;  VISITOR_DATA_TYPE = "com.googlecode.axs.ShortVector";  VISITOR_RETURN_TYPE = "Object";	//  NODE_CLASS = "XPathNode";}PARSER_BEGIN(Parser)package com.googlecode.axs.xpath;

public class Parser{  public static void main(String args [])  {    System.out.println("Reading from standard input...");    System.out.print("Enter an expression like /root/node1//node3[@attr='foo'] : ");    Parser p = new Parser(System.in);    try    {      SimpleNode n = (SimpleNode) p.Start();      n.dump("");      System.out.println("Thank you.");    }    catch (Exception e)    {      System.out.println("Oops.");      System.out.println(e.getMessage());    }  }}PARSER_END(Parser)SKIP : /* tolerate errant whitespace */{  " "| "\t"| "\r"| "\n"}MORE : /* Comments */{  "(:" : IN_COMMENT}<IN_COMMENT>SPECIAL_TOKEN :{  < COMMENT : "*)" > : DEFAULT}<IN_COMMENT>MORE :{  < ~[] >}TOKEN : /* Literals */{  < INTEGER_LITERAL : ("-")? ([ "0"-"9" ])+ >| < DQUOT_LITERAL : "\"" ( (~["\\"]) | "\"\"" )* "\"" >| < SQUOT_LITERAL : "'" ( (~["'"]) | "''" )* "'" >}TOKEN : /* Operators */{  < EQ : "=" >| < NE : "!=" >| < LT : "<" >| < GT : ">" >| < LE : "<=" >| < GE : ">=" >}Node Start() :{}{  Expression() ( "|" Expression() )*  {    return jjtThis;  }}void Expression() :{}{  ( Slash() | SlashSlash() )? StepExpression()  ( ( Slash() | SlashSlash() ) StepExpression() )*}void Slash() :{}{  "/"}void SlashSlash() :{}{  "//"}void StepExpression() :{}{  ForwardAxisStep() ( Predicate() )*}void ForwardAxisStep() #void :{}{  NameValue()}void Predicate() :{}{  LOOKAHEAD(3)  "[" IntegerValue() "]"| "[" OrExpression() "]"}void OrExpression() #OrExpression(>1) :{}{  AndExpression() ( "or" AndExpression() )*}void AndExpression() #AndExpression(>1) :{}{  BooleanExpression() ( "and" BooleanExpression() )*| "(" OrExpression() ")"}void BooleanExpression() #void :{}{  NumericComparisonExpression()| StringComparisonExpression()| CaptureAttrsFunction()| StringSearchFunction()| NotExpression()}void NotExpression() :{}{  "not" "(" OrExpression() ")"}void NumericComparisonExpression() :{  Token t;}{  NumericExpression()  	( t = < EQ > | t = < NE > | t = < LT > | t = < GT > | t = < LE > | t = < GE > )  NumericExpression()  {    jjtThis.jjtSetValue(t.image);  }}void StringComparisonExpression() :{  Token t;}{  StringExpression()  	( t = < EQ > | t = < NE > )  StringExpression()  {    jjtThis.jjtSetValue(t.image);  }}void StringSearchFunction() :{  Token t;}{  (    t = "contains"  | t = "starts-with"  | t = "ends-with"//  | t = "matches" // FIXME: adding regexp support will take a bit of effort  )  "(" StringExpression() "," StringExpression() ")"  {    jjtThis.jjtSetValue(t.image);  }}void StringExpression() #void :{}{  StringValue()| AttributeExpression()}void NumericExpression() #void :{}{  IntegerValue()| PositionFunction()}void IntegerValue() :{  Token t;}{  t = < INTEGER_LITERAL >  {    jjtThis.jjtSetValue(t.image);  }}void StringValue() :{  Token t;}{  t = < DQUOT_LITERAL >| t = < SQUOT_LITERAL > {  	jjtThis.jjtSetValue(t.image); }}void AttributeExpression() :{}{  "attribute::" NameValue()| "@" NameValue()}void CaptureAttrsFunction() :{}{  "captureattrs" "(" ")"}void PositionFunction() :{}{  "position" "(" ")"}void FunctionExpression() :{  Token t;}{  t = "position" "(" ")"| t = "captureattrs" "(" ")"| t = "not" "(" OrExpression() ")"{  jjtThis.jjtSetValue(t.image);}}
void NameValue() :{  Token t;}{  t = < NAME >  {    jjtThis.jjtSetValue(t.image);  }}/* Names have the lowest priority when tokenizing */TOKEN : /* Names, taken from http://www.w3.org/TR/REC-xml/#NT-Name */{  < NAME : <NAME_START_CHAR> ( <NAME_CHAR> )* >| < #NAME_START_CHAR :		":"	| ["A"-"Z"]	| "_"	| ["a"-"z"]	| ["\u00C0"-"\u00D6"]	| ["\u00D8"-"\u00F6"]	| ["\u00F8"-"\u02FF"]	| ["\u0370"-"\u037D"]	| ["\u037F"-"\u1FFF"]	| ["\u200C"-"\u200D"]	| ["\u2070"-"\u218F"]	| ["\u2C00"-"\u2FEF"]	| ["\u3001"-"\uD7FF"]	| ["\uF900"-"\uFDCF"]	| ["\uFDF0"-"\uFFFD"]//	| ["\u10000"-"\uEFFFF"] // FIXME: can I express this in Java?  >| <  #NAME_CHAR : 		<NAME_START_CHAR>	| "-"	| "."	| ["0"-"9"]	| "\u00B7"	| ["\u0300"-"\u036F"]	| ["\u203F"-"\u2040"]  >}