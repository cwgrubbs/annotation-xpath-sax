/** * This is the parser for the subset of XPath which is allowed in {@literal @}XPath declarations. */options{  JDK_VERSION = "1.6";  STATIC = false;  UNICODE_INPUT = true;  FORCE_LA_CHECK = true;  CHOICE_AMBIGUITY_CHECK = 4;  OTHER_AMBIGUITY_CHECK = 4;  MULTI = true;  NODE_PREFIX = "";  VISITOR = true;  VISITOR_DATA_TYPE = "com.googlecode.axs.ShortVector";  VISITOR_RETURN_TYPE = "Object";	//  NODE_CLASS = "XPathNode";}PARSER_BEGIN(Parser)package com.googlecode.axs.xpath;

public class Parser{  public static void main(String args [])  {    System.out.println("Reading from standard input...");    System.out.print("Enter an expression like /root/node1//node3[@attr='foo'] : ");    Parser p = new Parser(System.in);    try    {      SimpleNode n = (SimpleNode) p.Start();      n.dump("");      System.out.println("Thank you.");    }    catch (Exception e)    {      System.out.println("Oops.");      System.out.println(e.getMessage());    }  }}PARSER_END(Parser)SKIP : /* tolerate errant whitespace */{  " "| "\t"| "\r"| "\n"}MORE : /* Comments */{  "(:" : IN_COMMENT}<IN_COMMENT>SPECIAL_TOKEN :{  < COMMENT : "*)" > : DEFAULT}<IN_COMMENT>MORE :{  < ~[] >}TOKEN : /* Literals */{  < INTEGER_LITERAL : ("-")? ([ "0"-"9" ])+ >| < DQUOT_LITERAL : "\"" ( (~["\\"]) | "\"\"" )* "\"" >| < SQUOT_LITERAL : "'" ( (~["'"]) | "''" )* "'" >}TOKEN : /* Operators */{  < EQ : "=" >| < NE : "!=" >| < LT : "<" >| < GT : ">" >| < LE : "<=" >| < GE : ">=" >}TOKEN : /* not-really-reserved words: add these to NameValue() as needed */{  < AND : "and" >| < OR : "or" >| < NOT : "not" >| < CONTAINS : "contains" >| < STARTS_WITH : "starts-with" >| < ENDS_WITH : "ends-with" >| < MATCHES : "matches" >| < POSITION : "position" >| < CAPTUREATTRS : "captureattrs" >}/* Names */TOKEN : /* Names, taken from http://www.w3.org/TR/REC-xml/#NT-Name */{  < NAME : <NAME_START_CHAR> ( <NAME_CHAR> )* >| < #NAME_START_CHAR :		":"	| ["A"-"Z"]	| "_"	| ["a"-"z"]	| ["\u00C0"-"\u00D6"]	| ["\u00D8"-"\u00F6"]	| ["\u00F8"-"\u02FF"]	| ["\u0370"-"\u037D"]	| ["\u037F"-"\u1FFF"]	| ["\u200C"-"\u200D"]	| ["\u2070"-"\u218F"]	| ["\u2C00"-"\u2FEF"]	| ["\u3001"-"\uD7FF"]	| ["\uF900"-"\uFDCF"]	| ["\uFDF0"-"\uFFFD"]//	| ["\u10000"-"\uEFFFF"] // FIXME: can I express this in Java?  >| <  #NAME_CHAR : 		<NAME_START_CHAR>	| "-"	| "."	| ["0"-"9"]	| "\u00B7"	| ["\u0300"-"\u036F"]	| ["\u203F"-"\u2040"]  >}Node Start() :{}{  Expression() ( "|" Expression() )*  {    return jjtThis;  }}void Expression() :{}{  ( Slash() | SlashSlash() )? StepExpression()  ( ( Slash() | SlashSlash() ) StepExpression() )*}void Slash() :{}{  "/"}void SlashSlash() :{}{  "//"}void StepExpression() :{}{  ForwardAxisStep() ( Predicate() )*}void ForwardAxisStep() #void :{}{  NameValue()}void Predicate() :{}{  (    LOOKAHEAD( SingleNumberPredicate() ) SingleNumberPredicate()  | "[" OrExpression() "]"  )}void SingleNumberPredicate() #void :{}{  "[" < INTEGER_LITERAL > "]"}void OrExpression() #OrExpression(>1) :{}{  AndExpression() ( < OR > AndExpression() )*}void AndExpression() #AndExpression(>1) :{}{  BooleanExpression() ( < AND > BooleanExpression() )*}void BooleanExpression() #void :{}{  (  LOOKAHEAD( StringExpression() ( < EQ > | < NE > ) ) StringComparisonExpression()  | "(" OrExpression() ")"   | CaptureAttrsFunction()  | StringSearchFunction()  | NotExpression()  | NumericComparisonExpression()  )}void NotExpression() :{}{  < NOT > "(" OrExpression() ")"}void NumericComparisonExpression() :{  Token t;}{  NumericExpression()  	( t = < EQ > | t = < NE > | t = < LT > | t = < GT > | t = < LE > | t = < GE > )  NumericExpression()  {    jjtThis.jjtSetValue(t.image);  }}void StringComparisonExpression() :{  Token t;}{  StringExpression()  	( t = < EQ > | t = < NE > )  StringExpression()  {    jjtThis.jjtSetValue(t.image);  }}void StringSearchFunction() :{  Token t;}{  (    t = < CONTAINS >  | t = < STARTS_WITH >  | t = < ENDS_WITH >//  | t = < MATCHES > // FIXME: adding regexp support will take a bit of effort  )  "(" StringExpression() "," StringExpression() ")"  {    jjtThis.jjtSetValue(t.image);  }}void StringExpression() #void :{}{  StringValue()| AttributeExpression()}void NumericExpression() #void :{}{  IntegerValue()| PositionFunction()}void IntegerValue() :{  Token t;}{  t = < INTEGER_LITERAL >  {    jjtThis.jjtSetValue(t.image);  }}void StringValue() :{  Token t;}{  t = < DQUOT_LITERAL >| t = < SQUOT_LITERAL > {  	jjtThis.jjtSetValue(t.image); }}void AttributeExpression() :{}{  "@" NameValue()| NameValue()}void CaptureAttrsFunction() :{}{  < CAPTUREATTRS > "(" ")"}void PositionFunction() :{}{  < POSITION > "(" ")"}void NameValue() :{  Token t;}{  t = < NAME >  {    jjtThis.jjtSetValue(t.image);  }| (    (      t = < AND >    | t = < OR >    | t = < NOT >    | t = < CONTAINS >    | t = < STARTS_WITH >    | t = < ENDS_WITH >    | t = < MATCHES >    | t = < POSITION >    | t = < CAPTUREATTRS >    )    {      jjtThis.jjtSetValue(t.image);    }/*    (       t = < NAME >       {         jjtThis.jjtSetValue(jjtThis.jjtGetValue().toString() + t.image);       }     )**/   )}