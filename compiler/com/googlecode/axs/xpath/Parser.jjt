/** * This is the parser for the subset of XPath which is allowed in {@literal @}XPath declarations. */options{  JDK_VERSION = "1.6";  STATIC = false;  UNICODE_INPUT = true;  FORCE_LA_CHECK = true;  CHOICE_AMBIGUITY_CHECK = 4;  OTHER_AMBIGUITY_CHECK = 4;  NODE_CLASS = "XPathNode";}PARSER_BEGIN(Parser)package com.googlecode.axs.xpath;

public class Parser{  public static void main(String args [])  {    System.out.println("Reading from standard input...");    System.out.print("Enter an expression like /root/node1//node3[@attr='foo'] : ");    Parser p = new Parser(System.in);    try    {      SimpleNode n = p.Start();      n.dump("");      System.out.println("Thank you.");    }    catch (Exception e)    {      System.out.println("Oops.");      System.out.println(e.getMessage());    }  }}PARSER_END(Parser)SKIP : /* tolerate errant whitespace */{  " "| "\t"| "\r"| "\n"}MORE : /* Comments */{  "(:" : IN_COMMENT}<IN_COMMENT>SPECIAL_TOKEN :{  < COMMENT : "*)" > : DEFAULT}<IN_COMMENT>MORE :{  < ~[] >}TOKEN : /* Literals */{  < INTEGER_LITERAL : ("-")? ([ "0"-"9" ])+ >| < DQUOT_LITERAL : "\"" ( (~["\\"]) | "\"\"" )* "\"" >| < SQUOT_LITERAL : "'" ( (~["'"]) | "''" )* "'" >}TOKEN : /* Operators */{  < EQ : "=" >| < NE : "!=" >| < LT : "<" >| < GT : ">" >| < LE : "<=" >| < GE : ">=" >}XPathNode Start() :{}{  Expression() ( "|" Expression() )*  {    return jjtThis;  }}void Expression() :{}{  AbsolutePathExpression()| "//" RelativePathExpression()| RelativePathExpression()}void AbsolutePathExpression() :{}{  "/" RelativePathExpression()}void RelativePathExpression() #void :{}{  StepExpression() ( LOOKAHEAD(2) ChildExpression() | DecendentExpression() )*}void ChildExpression() :{}{  "/" StepExpression()}void DecendentExpression() :{}{  "//" StepExpression()}void StepExpression() #void :{}{  ForwardAxisStep() ( Predicate() )*}void ForwardAxisStep() #void :{}{  Name()| Wildcard()}void Wildcard() :{}{  "*"}void Predicate() :{}{  LOOKAHEAD(3)  "[" Integer() "]"| "[" OrExpression() "]"}void OrExpression() #OrExpression(>1) :{}{  AndExpression() ( "or" AndExpression() )*}void AndExpression() #AndExpression(>1) :{}{  ComparisonExpression() ( "and" ComparisonExpression() )*}void ComparisonExpression() :{  Token t;}{  ValueExpression()  	( t = < EQ > | t = < NE > | t = < LT > | t = < GT > | t = < LE > | t = < GE > ) ValueExpression()  {    jjtThis.jjtSetValue(t.image);  }}void ValueExpression() #void :{}{  ( "(" OrExpression() ")" )  | Integer()  | String()  | AttributeExpression()  | FunctionExpression()}void Integer() :{  Token t;}{  t = < INTEGER_LITERAL >  {    jjtThis.jjtSetValue(t.image);  }}void String() :{  Token t;}{  t = < DQUOT_LITERAL >| t = < SQUOT_LITERAL > {  	jjtThis.jjtSetValue(t.image); }}void AttributeExpression() :{}{  Name()| "@" Name()}void FunctionExpression() :{  Token t;}{  t = "position" "(" ")"| t = "captureattrs" "(" ")"| t = "not" "(" OrExpression() ")"{  jjtThis.jjtSetValue(t.image);}}
void Name() :{  Token t;}{  t = < NAME >  {    jjtThis.jjtSetValue(t.image);  }}/* Names have the lowest priority when tokenizing */TOKEN : /* Names, taken from http://www.w3.org/TR/REC-xml/#NT-Name */{  < NAME : <NAME_START_CHAR> ( <NAME_CHAR> )* >| < #NAME_START_CHAR :		":"	| ["A"-"Z"]	| "_"	| ["a"-"z"]	| ["\u00C0"-"\u00D6"]	| ["\u00D8"-"\u00F6"]	| ["\u00F8"-"\u02FF"]	| ["\u0370"-"\u037D"]	| ["\u037F"-"\u1FFF"]	| ["\u200C"-"\u200D"]	| ["\u2070"-"\u218F"]	| ["\u2C00"-"\u2FEF"]	| ["\u3001"-"\uD7FF"]	| ["\uF900"-"\uFDCF"]	| ["\uFDF0"-"\uFFFD"]//	| ["\u10000"-"\uEFFFF"] // FIXME: can I express this in Java?  >| <  #NAME_CHAR : 		<NAME_START_CHAR>	| "-"	| "."	| ["0"-"9"]	| "\u00B7"	| ["\u0300"-"\u036F"]	| ["\u203F"-"\u2040"]  >}