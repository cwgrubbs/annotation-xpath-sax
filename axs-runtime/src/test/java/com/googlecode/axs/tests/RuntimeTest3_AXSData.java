/* This class is autogenerated by the AXS compiler. Do not edit! */

/* **********************************************************************************/
/* Copyright (c) 2013 Benjamin K. Stuhl                                             */
/*                                                                                  */
/* Permission is hereby granted, free of charge, to any person obtaining a copy     */
/* of this software and associated documentation files (the "Software"), to deal    */
/* in the Software without restriction, including without limitation the rights     */
/* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies */
/* of the Software, and to permit persons to whom the Software is furnished to do   */
/* so, subject to the following conditions:                                         */
/*                                                                                  */
/* The above copyright notice and this permission notice shall be included in all   */
/* copies or substantial portions of the Software.                                  */
/*                                                                                  */
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR       */
/* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,         */
/* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE      */
/* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER           */
/* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,    */
/* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE    */
/* SOFTWARE.                                                                        */
/* **********************************************************************************/

package com.googlecode.axs.tests;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import javax.annotation.Generated;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;

import com.googlecode.axs.AXSData;
import com.googlecode.axs.AbstractAnnotatedHandler;
import com.googlecode.axs.HandlerCallError;
import com.googlecode.axs.QName;
import com.googlecode.axs.XPathExpression;

import com.googlecode.axs.tests.RuntimeTest3;


@Generated(value = { "com.googlecode.axs.AnnotationProcessor", "com.googlecode.axs.tests.RuntimeTest3"})
public class RuntimeTest3_AXSData implements AXSData {
    private static Object Lock = new Object();

    @Override
    public void callXPathText(AbstractAnnotatedHandler abstractHandler, int exprIx, String callbackArg) throws SAXException {
        RuntimeTest3 handler = (RuntimeTest3) abstractHandler;

        switch (exprIx) {
        case 0: 
            // "entry[@mod = 'moda'][@key = 'keyb']//value[@type='type2']"
            handler.testPredicateRetrial(callbackArg);
            break;
        default: throw new HandlerCallError("unhandled call #" + exprIx);
        }
    }

    @Override
    public void callXPathEnd(AbstractAnnotatedHandler abstractHandler, int exprIx) throws SAXException {
        RuntimeTest3 handler = (RuntimeTest3) abstractHandler;

        switch (exprIx) {
        default: throw new HandlerCallError("unhandled call #" + exprIx);
        }
    }

    @Override
    public void callXPathStart(AbstractAnnotatedHandler abstractHandler, int exprIx, Attributes callbackArg) throws SAXException {
        RuntimeTest3 handler = (RuntimeTest3) abstractHandler;

        switch (exprIx) {
        default: throw new HandlerCallError("unhandled call #" + exprIx);
        }
    }

    @Override
    public int getAXSDataVersion() {
        return 65536;
    }

    @Override
    public int getNumberOfCapturingExpressions() {
        return 1;
    }

    @Override
    public int getNumberOfEndExpressions() {
        return 0;
    }

    @Override
    public int getMaximumPredicateStackDepth() {
        return 1;
    }

    private static HashMap<String, int[]> Triggers = null;

    @Override
    public Map<String, int[]> getTriggerTags() {
        synchronized (Lock) {
            if (Triggers != null)
                return Triggers;
            Triggers = new HashMap<String, int[]>();
            Triggers.put("value", 
                    new int[] { 0, });
        }
        return Triggers;
    }

    private static HashSet<String> AttributeCaptureTags = null;

    @Override
    public Set<String> getAttributeCaptureTags() {
        synchronized (Lock) {
            if (AttributeCaptureTags != null)
                return AttributeCaptureTags;

            AttributeCaptureTags = new HashSet<String>();
            AttributeCaptureTags.add("entry");
            AttributeCaptureTags.add("value");
        }
        return AttributeCaptureTags;
    }

    private static HashSet<String> PositionCaptureTags = null;

    @Override
    public Set<String> getPositionCaptureTags() {
        synchronized (Lock) {
            if (PositionCaptureTags != null)
                return PositionCaptureTags;

            PositionCaptureTags = new HashSet<String>();
        }
        return PositionCaptureTags;
    }

    private static String[] Literals = new String[] {
        "type2",
        "moda",
        "keyb",
    };

    private static QName[] QNames = new QName[] {
        new QName("", "type"),
        new QName("", "value"),
        new QName("", "entry"),
        new QName("", "mod"),
        new QName("", "key"),
    };

    private static XPathExpression[] Expressions = new XPathExpression[] {
        new XPathExpression( // "entry[@mod = 'moda'][@key = 'keyb']//value[@type='type2']"
        new short[] {
            XPathExpression.INSTR_ATTRIBUTE, 0,
            XPathExpression.INSTR_LITERAL, 0,
            XPathExpression.INSTR_EQ_STR,
            XPathExpression.INSTR_TEST_PREDICATE,
            XPathExpression.INSTR_ELEMENT, 1,
            XPathExpression.INSTR_NONCONSECUTIVE_ELEMENT, 2,
            XPathExpression.INSTR_ATTRIBUTE, 3,
            XPathExpression.INSTR_LITERAL, 1,
            XPathExpression.INSTR_EQ_STR,
            XPathExpression.INSTR_SOFT_TEST_PREDICATE, -7,
            XPathExpression.INSTR_ATTRIBUTE, 4,
            XPathExpression.INSTR_LITERAL, 2,
            XPathExpression.INSTR_EQ_STR,
            XPathExpression.INSTR_SOFT_TEST_PREDICATE, -14,
            XPathExpression.INSTR_ELEMENT, 2,
        }, QNames, Literals),
    };

    public XPathExpression[] getXPathExpressions() {
        return Expressions;
    }
}
