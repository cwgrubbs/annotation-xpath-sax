/* This class is autogenerated by the AXS compiler. Do not edit! */

/* **********************************************************************************/
/* Copyright (c) 2013 Benjamin K. Stuhl                                             */
/*                                                                                  */
/* Permission is hereby granted, free of charge, to any person obtaining a copy     */
/* of this software and associated documentation files (the "Software"), to deal    */
/* in the Software without restriction, including without limitation the rights     */
/* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies */
/* of the Software, and to permit persons to whom the Software is furnished to do   */
/* so, subject to the following conditions:                                         */
/*                                                                                  */
/* The above copyright notice and this permission notice shall be included in all   */
/* copies or substantial portions of the Software.                                  */
/*                                                                                  */
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR       */
/* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,         */
/* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE      */
/* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER           */
/* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,    */
/* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE    */
/* SOFTWARE.                                                                        */
/* **********************************************************************************/

package com.googlecode.axs.tests;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import javax.annotation.Generated;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;

import com.googlecode.axs.AXSData;
import com.googlecode.axs.AbstractAnnotatedHandler;
import com.googlecode.axs.HandlerCallError;
import com.googlecode.axs.QName;
import com.googlecode.axs.XPathExpression;

import com.googlecode.axs.tests.CompilationTest;


@Generated(value = { "com.googlecode.axs.AnnotationProcessor", "com.googlecode.axs.tests.CompilationTest"})
public class CompilationTest_AXSData implements AXSData {
    private static Object Lock = new Object();

    @Override
    public void callXPathText(AbstractAnnotatedHandler abstractHandler, int exprIx, String callbackArg) throws SAXException {
        CompilationTest handler = (CompilationTest) abstractHandler;

        switch (exprIx) {
        case 0: 
            // "foo/ (: not baz :) bar"
            handler.barElement(callbackArg);
            break;
        case 1: 
            // "/grep[captureattrs()]//foo[2]"
            handler.fooElement2(callbackArg);
            break;
        default: throw new HandlerCallError("unhandled call #" + exprIx);
        }
    }

    @Override
    public void callXPathEnd(AbstractAnnotatedHandler abstractHandler, int exprIx) throws SAXException {
        CompilationTest handler = (CompilationTest) abstractHandler;

        switch (exprIx) {
        case 2: 
            // "/grep[@is != 'awk']//awk[2]"
            handler.awkElementEnd();
            break;
        case 3: 
            // "grep[@is = 'awk']/not"
            handler.notElementEnd();
            break;
        default: throw new HandlerCallError("unhandled call #" + exprIx);
        }
    }

    @Override
    public void callXPathStart(AbstractAnnotatedHandler abstractHandler, int exprIx, Attributes callbackArg) throws SAXException {
        CompilationTest handler = (CompilationTest) abstractHandler;

        switch (exprIx) {
        case 4: 
            // "/baz//blah"
            handler.blahElement(callbackArg);
            break;
        case 5: 
            // "foo/baz/blah/blah"
            handler.blahElement2(callbackArg);
            break;
        default: throw new HandlerCallError("unhandled call #" + exprIx);
        }
    }

    @Override
    public int getAXSDataVersion() {
        return 65536;
    }

    @Override
    public int getNumberOfCapturingExpressions() {
        return 2;
    }

    @Override
    public int getNumberOfEndExpressions() {
        return 2;
    }

    @Override
    public int getMaximumPredicateStackDepth() {
        return 2;
    }

    private static HashMap<String, int[]> Triggers = null;

    @Override
    public Map<String, int[]> getTriggerTags() {
        synchronized (Lock) {
            if (Triggers != null)
                return Triggers;
            Triggers = new HashMap<String, int[]>();
            Triggers.put("bar", 
                    new int[] { 0, });
            Triggers.put("not", 
                    new int[] { 3, });
            Triggers.put("awk", 
                    new int[] { 2, });
            Triggers.put("foo", 
                    new int[] { 1, });
            Triggers.put("blah", 
                    new int[] { 4, 5, });
        }
        return Triggers;
    }

    private static HashSet<String> AttributeCaptureTags = null;

    @Override
    public Set<String> getAttributeCaptureTags() {
        synchronized (Lock) {
            if (AttributeCaptureTags != null)
                return AttributeCaptureTags;

            AttributeCaptureTags = new HashSet<String>();
            AttributeCaptureTags.add("grep");
        }
        return AttributeCaptureTags;
    }

    private static HashSet<String> PositionCaptureTags = null;

    @Override
    public Set<String> getPositionCaptureTags() {
        synchronized (Lock) {
            if (PositionCaptureTags != null)
                return PositionCaptureTags;

            PositionCaptureTags = new HashSet<String>();
            PositionCaptureTags.add("awk");
            PositionCaptureTags.add("foo");
        }
        return PositionCaptureTags;
    }

    private static String[] Literals = new String[] {
        "awk",
    };

    private static QName[] QNames = new QName[] {
        new QName("http://foo.bar/NS1", "bar"),
        new QName("http://foo.bar/NS1", "foo"),
        new QName("http://foo.bar/NS1", "grep"),
        new QName("http://foo.bar/NS1", "awk"),
        new QName("", "is"),
        new QName("http://foo.bar/NS1", "not"),
        new QName("http://foo.bar/NS1", "blah"),
        new QName("http://foo.bar/NS1", "baz"),
    };

    private static XPathExpression[] Expressions = new XPathExpression[] {
        new XPathExpression( // "foo/ (: not baz :) bar"
        new short[] {
            XPathExpression.INSTR_ELEMENT, 0,
            XPathExpression.INSTR_ELEMENT, 1,
        }, QNames, Literals),
        new XPathExpression( // "/grep[captureattrs()]//foo[2]"
        new short[] {
            XPathExpression.INSTR_POSITION,
            XPathExpression.INSTR_ILITERAL, 2,
            XPathExpression.INSTR_EQ,
            XPathExpression.INSTR_TEST_PREDICATE,
            XPathExpression.INSTR_ELEMENT, 1,
            XPathExpression.INSTR_NONCONSECUTIVE_ELEMENT, 2,
            XPathExpression.INSTR_ILITERAL, 1,
            XPathExpression.INSTR_SOFT_TEST_PREDICATE, -4,
            XPathExpression.INSTR_ELEMENT, 2,
            XPathExpression.INSTR_ROOT,
        }, QNames, Literals),
        new XPathExpression( // "/grep[@is != 'awk']//awk[2]"
        new short[] {
            XPathExpression.INSTR_POSITION,
            XPathExpression.INSTR_ILITERAL, 2,
            XPathExpression.INSTR_EQ,
            XPathExpression.INSTR_TEST_PREDICATE,
            XPathExpression.INSTR_ELEMENT, 3,
            XPathExpression.INSTR_NONCONSECUTIVE_ELEMENT, 2,
            XPathExpression.INSTR_ATTRIBUTE, 4,
            XPathExpression.INSTR_LITERAL, 0,
            XPathExpression.INSTR_EQ_STR,
            XPathExpression.INSTR_NOT,
            XPathExpression.INSTR_SOFT_TEST_PREDICATE, -8,
            XPathExpression.INSTR_ELEMENT, 2,
            XPathExpression.INSTR_ROOT,
        }, QNames, Literals),
        new XPathExpression( // "grep[@is = 'awk']/not"
        new short[] {
            XPathExpression.INSTR_ELEMENT, 5,
            XPathExpression.INSTR_ATTRIBUTE, 4,
            XPathExpression.INSTR_LITERAL, 0,
            XPathExpression.INSTR_EQ_STR,
            XPathExpression.INSTR_TEST_PREDICATE,
            XPathExpression.INSTR_ELEMENT, 2,
        }, QNames, Literals),
        new XPathExpression( // "/baz//blah"
        new short[] {
            XPathExpression.INSTR_ELEMENT, 6,
            XPathExpression.INSTR_NONCONSECUTIVE_ELEMENT, 7,
            XPathExpression.INSTR_ELEMENT, 7,
            XPathExpression.INSTR_ROOT,
        }, QNames, Literals),
        new XPathExpression( // "foo/baz/blah/blah"
        new short[] {
            XPathExpression.INSTR_ELEMENT, 6,
            XPathExpression.INSTR_ELEMENT, 6,
            XPathExpression.INSTR_ELEMENT, 7,
            XPathExpression.INSTR_ELEMENT, 1,
        }, QNames, Literals),
    };

    public XPathExpression[] getXPathExpressions() {
        return Expressions;
    }
}
