This is Annotation XPath for SAX, AXS. It is copyrighted by Benjamin K. Stuhl and
is made freely available under the terms described in LICENSE. All of the code
generated by the attribute processor is also licensed under the same terms as this
package.

I. INTRODUCTION AND EXAMPLE

AXS (pronounced "axis") is an effort to make writing SAX DocumentHandlers easy. An AXS
handler subclasses com.googlecode.axs.AbstractAnnotatedHandler and then instead of
(or in addition to) the usual startElement(), endElement(), etc. SAX handlers, you
can write annotated handlers which are called when the current element in the document
being parsed matches an XPath expression. For example, if one had a document

<person>
  <names>
    <name>John Smith</name>
    <name type="alias">Kyon</name>
    <name type="alias">Hey, you!</name>
  </names>
  <age span="subjective">18.32</age>
  <age span="years-since-birth">16.1</age>
  <locations>
    <location>
  	  <country>Japan</country>
  	  <era>mid-Haruhi</era>
  	</location>
  	<location>
  	  <country>alternate-Japan@3c603ff:110bb8e</country>
  	  <era>elided-Haruhi</era>
  	  <subsidary-universe/>
  </locations>
</person>

the handler function

@XPath("names/name[@type != 'alias'")
public void realName(String name) { ... }

would be called exactly once with the string "John Smith". Similarly, a function

@XPath("locations/location/country")
public void whereIsHeNow(String country) { ... }

would be called twice, once with "Japan" and once with "alternate-Japan@3c603ff:110bb8e".


II. USING AXS

AXS provides two JAR files, one of which ("axs-runtime") must be included in your application.
The other JAR ("axs-compiler") must be added to your project as an attribute processor for
javac. For the Oracle (Sun) javac, this is done by using the -processorpath command line
argument. In an Ant <javac> task, this can be done with <compilerarg> elements.

<javac...>
  <compilerarg value="-processorpath"/>
  <compilerarg value="${axs-compiler-jar}"/>
  <compilerarg value="-s"/>
  <compilerarg value="${generated-code-dir}"/>
</javac>

Then, the code generated by the attribute processor must also be compiled and included into your
application.


III. THE AXS @ATTRIBUTES

AXS provides four attributes, one which applies to the handler class and three which
apply to specific handler methods. The attributes are

1. @XPathNamespaces(String[] namespacePairs)

  This attribute is applied to the handler class, and defines the qualified name (QName)
  Prefix to Namespace URI mappings used for all the XPath expressions in this path. If
  this attribute is not present, a single mapping of the null Prefix ("") to the null
  Namespace URI ("") is used. The strings are of the form "prefix=URI", e. g.
  "html=http://www.w3.org/1999/xhtml" defines that the Prefix "html" referrs to elements
  in the XHTML namespace. Any prefix, including the null prefix, can be mapped.

2. @XPath(String xpathExpression)

  This attribute is applied to a handler method, and specifies that the method will be
  called with the text enclosed by the right-most Element of the XPath expression.

3. @XPathStart(String xpathExpression)

  This attribute is applied to a handler method, and specifies that the method will be
  called with the SAX Attributes of the right-most Element of the XPath expression as
  soon as that Element is started.

  To continue on the example, if one wanted to know all the different ways that John Smith's
  age is tracked, the handler function

  @XPathStart("/person/age")
  public void foundAnAge(org.xml.sax.Attributes attrs) { ... }

  would be called twice, once for each <age> element.

4. @XPathEnd(String xpathExpression)

  This attribute is applied to a handler method, and specifies that the method will be
  called when the right-most Element of the XPath expression is ended.

  In the example, if one wanted to stop parsing as soon as two aliases were found,
  the handler function

  @XPathEnd("/person/names/name[@type='alias'][2]")
  public void gotTwoAliases() { throw new SAXException("got what we needed"); }

  would do so by throwing a SAXException after the </name> tag of the "Hey, you!" entry.

Multiple XPath expressions may be combined in a single attribute by using the '|' character
to separate alternatives.

IV. SUBSET OF XPATH UNDERSTOOD BY AXS

AXS handles only a subset of the full XPath specification. Since SAX is a streaming parser,
AXS only accepts forward path steps, and specifically only the child:: and decendent:: axes.
Every path step must have an element (no attribute-only steps), and wildcards elements ('*')
are not permitted. Use the decendent:: (i.e. //) axis instead.

Only a few predicates are accepted:
  - the numeric singleton predicate [N]  which selects the element at Context
    Position N (e.g. names/child::name[2] selects the 2nd <name> that is a child of <names>)
  - string value comparisons $A CMP $B where CMP is either '=' or '!=' and $A and $B are
    either string literals ('value' or "value"; for either form, a doubled delimiter is the
    escape sequence to write that delimiter, e.g. 'a''b' is the literal "a'b" and likewise
    "a""b" is 'a"b') or attribute names, either attribute::NAME or @NAME
  - string match functions "contains(a, b)", "starts-with(a, b)", and "ends-with(a, b)" where
    A and B are either literals or attribute names
  - numeric comparisons to the position() function (e.g. [position() < 4] selects the first
    three matches)
  - the special function [captureattrs()] which ensures that the attributes of the
    Element to which it is applied will be available when the handler function is called
    (see section V). This predicate is always true.
  - parenthesized expressions, the "and" and "or" boolean operators, and the function
    "not(EXPR)"

AXS accepts both the unabbreviated (child::, decendent::, attribute::) naming forms and the
abbreviated (@? Name) forms.


V. ADDITIONAL INFORMATION AVAILABLE TO HANDLER FUNCTIONS

AbstractAnnotatedHandler provides several functions which may be called by a handler
function to request more information about the context of the handler call:

1. int tagDepth()

  Returns how many elements deep the current path is to the root.

2. QName tagAtDepth(int depth)

  Returns the tag at a given depth in the current path. Depth 0 is the root element.

3. int findTag(QName tag[, int start])

  Returns the depth at which the tag can be found, or -1 if it was not found. Can optionally
  take the depth at which to start an incremental search.

4. Map<QName, String> attributesAtDepth(int depth)

  Returns the attributes of the tag at a given depth, or null if they are not available.
  Note that the attributes of a given tag will only be available if they were used in a
  predicate, or of the special [captureattrs()] predicate was used. 

Handler subclasses are also free to implement all the usual SAX DocumentHandler methods
themselves if needed, but they must call the superclass implementation as well.

